"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./services/ws.ts":
/*!************************!*\
  !*** ./services/ws.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TelemetryWebSocket: function() { return /* binding */ TelemetryWebSocket; },\n/* harmony export */   telemetryClient: function() { return /* binding */ telemetryClient; }\n/* harmony export */ });\n/**\n * WebSocket Telemetry Client Service\n * Handles connection, reconnection, and telemetry streaming\n */ class TelemetryWebSocket {\n    connect(url) {\n        if (url) {\n            this.url = url;\n        }\n        if (!this.url) {\n            this.url = \"ws://localhost:8000/ws\";\n        }\n        return new Promise((resolve, reject)=>{\n            try {\n                this.ws = new WebSocket(this.url);\n                this.ws.onopen = ()=>{\n                    console.log(\"[v0] WebSocket connected\");\n                    this.reconnectAttempts = 0;\n                    this.reconnectDelay = 1000;\n                    this.notifyStatusListeners(true);\n                    resolve();\n                };\n                this.ws.onmessage = (event)=>{\n                    try {\n                        const data = JSON.parse(event.data);\n                        this.notifyListeners(data);\n                    } catch (e) {\n                        console.error(\"[v0] Failed to parse telemetry:\", e);\n                    }\n                };\n                this.ws.onerror = (error)=>{\n                    console.error(\"[v0] WebSocket error:\", error);\n                    reject(error);\n                };\n                this.ws.onclose = ()=>{\n                    console.log(\"[v0] WebSocket closed\");\n                    this.notifyStatusListeners(false);\n                    this.attemptReconnect();\n                };\n            } catch (error) {\n                console.error(\"[v0] Connection error:\", error);\n                reject(error);\n            }\n        });\n    }\n    attemptReconnect() {\n        if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n            console.error(\"[v0] Max reconnection attempts reached\");\n            return;\n        }\n        this.reconnectAttempts++;\n        const delay = Math.min(this.reconnectDelay * Math.pow(1.5, this.reconnectAttempts - 1), this.maxReconnectDelay);\n        console.log(\"[v0] Reconnecting in \".concat(delay, \"ms (attempt \").concat(this.reconnectAttempts, \"/\").concat(this.maxReconnectAttempts, \")\"));\n        setTimeout(()=>{\n            this.connect().catch(()=>{\n            // Error will trigger onclose which calls attemptReconnect\n            });\n        }, delay);\n    }\n    subscribe(listener) {\n        this.listeners.add(listener);\n        return ()=>this.listeners.delete(listener);\n    }\n    subscribeToStatus(listener) {\n        this.statusListeners.add(listener);\n        return ()=>this.statusListeners.delete(listener);\n    }\n    notifyListeners(data) {\n        this.listeners.forEach((listener)=>{\n            try {\n                listener(data);\n            } catch (e) {\n                console.error(\"[v0] Error in telemetry listener:\", e);\n            }\n        });\n    }\n    notifyStatusListeners(connected) {\n        this.statusListeners.forEach((listener)=>{\n            try {\n                listener(connected);\n            } catch (e) {\n                console.error(\"[v0] Error in status listener:\", e);\n            }\n        });\n    }\n    disconnect() {\n        if (this.ws) {\n            this.ws.close();\n            this.ws = null;\n        }\n    }\n    isConnected() {\n        var _this_ws;\n        return ((_this_ws = this.ws) === null || _this_ws === void 0 ? void 0 : _this_ws.readyState) === WebSocket.OPEN;\n    }\n    constructor(url){\n        this.ws = null;\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 10;\n        this.reconnectDelay = 1000;\n        this.maxReconnectDelay = 30000;\n        this.listeners = new Set();\n        this.statusListeners = new Set();\n        // Will be set dynamically when connect() is called\n        this.url = url || \"\";\n    }\n}\n// Export singleton instance\nconst telemetryClient = new TelemetryWebSocket();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0FBT0ksR0FBRztnQkFDVlgsUUFBUVksS0FBSyxDQUFDLHFDQUFxQ0Q7WUFDckQ7UUFDRjtJQUNGO0lBRVFQLHNCQUFzQjRCLFNBQWtCLEVBQVE7UUFDdEQsSUFBSSxDQUFDRixlQUFlLENBQUNDLE9BQU8sQ0FBQyxDQUFDTjtZQUM1QixJQUFJO2dCQUNGQSxTQUFTTztZQUNYLEVBQUUsT0FBT3JCLEdBQUc7Z0JBQ1ZYLFFBQVFZLEtBQUssQ0FBQyxrQ0FBa0NEO1lBQ2xEO1FBQ0Y7SUFDRjtJQUVBc0IsYUFBbUI7UUFDakIsSUFBSSxJQUFJLENBQUNwQyxFQUFFLEVBQUU7WUFDWCxJQUFJLENBQUNBLEVBQUUsQ0FBQ3FDLEtBQUs7WUFDYixJQUFJLENBQUNyQyxFQUFFLEdBQUc7UUFDWjtJQUNGO0lBRUFzQyxjQUF1QjtZQUNkO1FBQVAsT0FBTyxpQkFBSSxDQUFDdEMsRUFBRSxjQUFQLHdDQUFTdUMsVUFBVSxNQUFLdEMsVUFBVXVDLElBQUk7SUFDL0M7SUE1R0FDLFlBQVk3QyxHQUFZLENBQUU7YUFUbEJJLEtBQXVCO2FBRXZCSyxvQkFBb0I7YUFDcEJjLHVCQUF1QjthQUN2QmIsaUJBQWlCO2FBQ2pCa0Isb0JBQW9CO2FBQ3BCSyxZQUFnRCxJQUFJYTthQUNwRFQsa0JBQXFELElBQUlTO1FBRy9ELG1EQUFtRDtRQUNuRCxJQUFJLENBQUM5QyxHQUFHLEdBQUdBLE9BQU87SUFDcEI7QUEwR0Y7QUFFQSw0QkFBNEI7QUFDckIsTUFBTStDLGtCQUFrQixJQUFJakQscUJBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NlcnZpY2VzL3dzLnRzP2VhNmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBXZWJTb2NrZXQgVGVsZW1ldHJ5IENsaWVudCBTZXJ2aWNlXG4gKiBIYW5kbGVzIGNvbm5lY3Rpb24sIHJlY29ubmVjdGlvbiwgYW5kIHRlbGVtZXRyeSBzdHJlYW1pbmdcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIFRlbGVtZXRyeURhdGEge1xuICB0aW1lc3RhbXA6IHN0cmluZ1xuICBjb25uZWN0ZWQ6IGJvb2xlYW5cbiAgcG9zaXRpb24/OiB7XG4gICAgbGF0OiBudW1iZXJcbiAgICBsb246IG51bWJlclxuICAgIHJlbGF0aXZlX2FsdF9tOiBudW1iZXJcbiAgICBhYnNvbHV0ZV9hbHRfbTogbnVtYmVyXG4gIH1cbiAgYXR0aXR1ZGU/OiB7XG4gICAgcm9sbF9kZWc6IG51bWJlclxuICAgIHBpdGNoX2RlZzogbnVtYmVyXG4gICAgeWF3X2RlZzogbnVtYmVyXG4gIH1cbiAgdmVsb2NpdHk/OiB7XG4gICAgbm9ydGhfbV9zOiBudW1iZXJcbiAgICBlYXN0X21fczogbnVtYmVyXG4gICAgZG93bl9tX3M6IG51bWJlclxuICB9XG4gIGJhdHRlcnk/OiB7XG4gICAgdm9sdGFnZV92OiBudW1iZXJcbiAgICByZW1haW5pbmdfcGVyY2VudDogbnVtYmVyXG4gIH1cbiAgZmxpZ2h0X21vZGU/OiBzdHJpbmdcbiAgaGVhbHRoPzoge1xuICAgIGlzX2d5cm9tZXRlcl9jYWxpYnJhdGlvbl9vazogYm9vbGVhblxuICAgIGlzX2FjY2VsZXJvbWV0ZXJfY2FsaWJyYXRpb25fb2s6IGJvb2xlYW5cbiAgICBpc19tYWduZXRvbWV0ZXJfY2FsaWJyYXRpb25fb2s6IGJvb2xlYW5cbiAgICBpc19sZXZlbF9jYWxpYnJhdGlvbl9vazogYm9vbGVhblxuICAgIGlzX2xvY2FsX3Bvc2l0aW9uX29rOiBib29sZWFuXG4gICAgaXNfZ2xvYmFsX3Bvc2l0aW9uX29rOiBib29sZWFuXG4gICAgaXNfaG9tZV9wb3NpdGlvbl9vazogYm9vbGVhblxuICAgIGlzX2FybWFibGU6IGJvb2xlYW5cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVGVsZW1ldHJ5V2ViU29ja2V0IHtcbiAgcHJpdmF0ZSB3czogV2ViU29ja2V0IHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSB1cmw6IHN0cmluZ1xuICBwcml2YXRlIHJlY29ubmVjdEF0dGVtcHRzID0gMFxuICBwcml2YXRlIG1heFJlY29ubmVjdEF0dGVtcHRzID0gMTBcbiAgcHJpdmF0ZSByZWNvbm5lY3REZWxheSA9IDEwMDBcbiAgcHJpdmF0ZSBtYXhSZWNvbm5lY3REZWxheSA9IDMwMDAwXG4gIHByaXZhdGUgbGlzdGVuZXJzOiBTZXQ8KGRhdGE6IFRlbGVtZXRyeURhdGEpID0+IHZvaWQ+ID0gbmV3IFNldCgpXG4gIHByaXZhdGUgc3RhdHVzTGlzdGVuZXJzOiBTZXQ8KGNvbm5lY3RlZDogYm9vbGVhbikgPT4gdm9pZD4gPSBuZXcgU2V0KClcblxuICBjb25zdHJ1Y3Rvcih1cmw/OiBzdHJpbmcpIHtcbiAgICAvLyBXaWxsIGJlIHNldCBkeW5hbWljYWxseSB3aGVuIGNvbm5lY3QoKSBpcyBjYWxsZWRcbiAgICB0aGlzLnVybCA9IHVybCB8fCBcIlwiXG4gIH1cblxuICBjb25uZWN0KHVybD86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh1cmwpIHtcbiAgICAgIHRoaXMudXJsID0gdXJsXG4gICAgfVxuICAgIGlmICghdGhpcy51cmwpIHtcbiAgICAgIHRoaXMudXJsID0gXCJ3czovL2xvY2FsaG9zdDo4MDAwL3dzXCJcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHRoaXMudXJsKVxuXG4gICAgICAgIHRoaXMud3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSBXZWJTb2NrZXQgY29ubmVjdGVkXCIpXG4gICAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDBcbiAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5ID0gMTAwMFxuICAgICAgICAgIHRoaXMubm90aWZ5U3RhdHVzTGlzdGVuZXJzKHRydWUpXG4gICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhOiBUZWxlbWV0cnlEYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKVxuICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoZGF0YSlcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW3YwXSBGYWlsZWQgdG8gcGFyc2UgdGVsZW1ldHJ5OlwiLCBlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMud3Mub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIFdlYlNvY2tldCBlcnJvcjpcIiwgZXJyb3IpXG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSBXZWJTb2NrZXQgY2xvc2VkXCIpXG4gICAgICAgICAgdGhpcy5ub3RpZnlTdGF0dXNMaXN0ZW5lcnMoZmFsc2UpXG4gICAgICAgICAgdGhpcy5hdHRlbXB0UmVjb25uZWN0KClcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlt2MF0gQ29ubmVjdGlvbiBlcnJvcjpcIiwgZXJyb3IpXG4gICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBhdHRlbXB0UmVjb25uZWN0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnJlY29ubmVjdEF0dGVtcHRzID49IHRoaXMubWF4UmVjb25uZWN0QXR0ZW1wdHMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIE1heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgcmVhY2hlZFwiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cysrXG4gICAgY29uc3QgZGVsYXkgPSBNYXRoLm1pbih0aGlzLnJlY29ubmVjdERlbGF5ICogTWF0aC5wb3coMS41LCB0aGlzLnJlY29ubmVjdEF0dGVtcHRzIC0gMSksIHRoaXMubWF4UmVjb25uZWN0RGVsYXkpXG5cbiAgICBjb25zb2xlLmxvZyhgW3YwXSBSZWNvbm5lY3RpbmcgaW4gJHtkZWxheX1tcyAoYXR0ZW1wdCAke3RoaXMucmVjb25uZWN0QXR0ZW1wdHN9LyR7dGhpcy5tYXhSZWNvbm5lY3RBdHRlbXB0c30pYClcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5jb25uZWN0KCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAvLyBFcnJvciB3aWxsIHRyaWdnZXIgb25jbG9zZSB3aGljaCBjYWxscyBhdHRlbXB0UmVjb25uZWN0XG4gICAgICB9KVxuICAgIH0sIGRlbGF5KVxuICB9XG5cbiAgc3Vic2NyaWJlKGxpc3RlbmVyOiAoZGF0YTogVGVsZW1ldHJ5RGF0YSkgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xuICAgIHRoaXMubGlzdGVuZXJzLmFkZChsaXN0ZW5lcilcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5saXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKVxuICB9XG5cbiAgc3Vic2NyaWJlVG9TdGF0dXMobGlzdGVuZXI6IChjb25uZWN0ZWQ6IGJvb2xlYW4pID0+IHZvaWQpOiAoKSA9PiB2b2lkIHtcbiAgICB0aGlzLnN0YXR1c0xpc3RlbmVycy5hZGQobGlzdGVuZXIpXG4gICAgcmV0dXJuICgpID0+IHRoaXMuc3RhdHVzTGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcilcbiAgfVxuXG4gIHByaXZhdGUgbm90aWZ5TGlzdGVuZXJzKGRhdGE6IFRlbGVtZXRyeURhdGEpOiB2b2lkIHtcbiAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIoZGF0YSlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlt2MF0gRXJyb3IgaW4gdGVsZW1ldHJ5IGxpc3RlbmVyOlwiLCBlKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIG5vdGlmeVN0YXR1c0xpc3RlbmVycyhjb25uZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLnN0YXR1c0xpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIoY29ubmVjdGVkKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiW3YwXSBFcnJvciBpbiBzdGF0dXMgbGlzdGVuZXI6XCIsIGUpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGRpc2Nvbm5lY3QoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMud3MpIHtcbiAgICAgIHRoaXMud3MuY2xvc2UoKVxuICAgICAgdGhpcy53cyA9IG51bGxcbiAgICB9XG4gIH1cblxuICBpc0Nvbm5lY3RlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU5cbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgdGVsZW1ldHJ5Q2xpZW50ID0gbmV3IFRlbGVtZXRyeVdlYlNvY2tldCgpXG4iXSwibmFtZXMiOlsiVGVsZW1ldHJ5V2ViU29ja2V0IiwiY29ubmVjdCIsInVybCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwid3MiLCJXZWJTb2NrZXQiLCJvbm9wZW4iLCJjb25zb2xlIiwibG9nIiwicmVjb25uZWN0QXR0ZW1wdHMiLCJyZWNvbm5lY3REZWxheSIsIm5vdGlmeVN0YXR1c0xpc3RlbmVycyIsIm9ubWVzc2FnZSIsImV2ZW50IiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsIm5vdGlmeUxpc3RlbmVycyIsImUiLCJlcnJvciIsIm9uZXJyb3IiLCJvbmNsb3NlIiwiYXR0ZW1wdFJlY29ubmVjdCIsIm1heFJlY29ubmVjdEF0dGVtcHRzIiwiZGVsYXkiLCJNYXRoIiwibWluIiwicG93IiwibWF4UmVjb25uZWN0RGVsYXkiLCJzZXRUaW1lb3V0IiwiY2F0Y2giLCJzdWJzY3JpYmUiLCJsaXN0ZW5lciIsImxpc3RlbmVycyIsImFkZCIsImRlbGV0ZSIsInN1YnNjcmliZVRvU3RhdHVzIiwic3RhdHVzTGlzdGVuZXJzIiwiZm9yRWFjaCIsImNvbm5lY3RlZCIsImRpc2Nvbm5lY3QiLCJjbG9zZSIsImlzQ29ubmVjdGVkIiwicmVhZHlTdGF0ZSIsIk9QRU4iLCJjb25zdHJ1Y3RvciIsIlNldCIsInRlbGVtZXRyeUNsaWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/ws.ts\n"));

/***/ })

});